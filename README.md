My project is a solo project that is a root solver class that finds the root of a function in or around a given interval using different solver methods.  Its main features include 4 functions.  One of these finds any root of the function while the other two find a root within the given interval using different numerical approximation methods. The last function returns a plot of the function over the given interval.
	
	The project contains one class named root.  This call has two inputs; the first is the given interval in tuple form, and the second is the precision of the root value calculated otherwise known as the number of significant figures past the decimal point.  The first attribute is the interval which is a protected attribute that has getter and setter methods.  The setter method ensures the interval is in tuple form, contains a root, and has a start point that is before the endpoint.  The precision attribute is the same as the given input.  When printed the class will return a statement saying 'Your interval is {given interval}'.
The next function is called func() which takes in an ‘x’ argument and returns the inputted function's corresponding value.  This is the method the user must input to add the function they want to solve for.  This function returns the corresponding y value at the given ‘x’ value.
The next function is called intervalChecker().  This function takes in a given interval and checks for three things.  It first checks the interval is a tuple.  It then checks if its start point is before its endpoint.  Finally, it checks if the interval can theoretically contain a root.  It does this by multiplying the corresponding func() outputs at the start and end points.  If this value is negative then the interval must contain a root given the function is continuous over the interval. If this value is positive even though the function could contain a root the program deems the interval invalid because there is no way to prove the interval must contain a root.  If all of these conditions are met then the function returns True but if any are not met then False is returned.
	In the interval.setter method the function takes in the given interval and checks if intervalChecker() is True or False.  If True then the interval value is set to the given.  If not an error is raised alerting the user, 'Interval must contain a root, be in tuple form, and be complete!'.
	The first function that must be called by the user is called funcPlot().  This function graphs the given function over the given interval.  It has a title labeled ‘Function’ and it's x and y labels are ‘x’ and ‘y’ respectively.
	
The first root solver method is called newtonsMethod().  This function takes no inputs from the user.  It first finds the midpoint of the interval and sets this value equal to x. Next, while the func(x) value is not close to zero (func(x) >= 1/10**precision or func(x) <=  -1/10**precision).  The method then finds the approximate derivate at that point.  Using that derivative the new x value is calculated using,
x = x -func(x)/func'(x)  
The process is then again repeated using this new x value until x is close to zero within the given precision.  When the root is found the message printed is, 'Newtons root x value with precision {self.precision}: {x:.{self.precision}f}.
The second root solver method is bisectionMethod().  This function takes in no inputs from the user.  It first takes in the start and end points of the interval as x0 and x1.  It then calculates the midpoint of these points as x2.  The function checks if func(x2) is close to zero within eh given precision.  While it is not, x2 is calculated again using the average of x0 and x1.  The method then used intervalChecker(x0,x2) to see if the new interval will contain the root.  If True x1 = x2. And the process is repeated until x2 is close to zero.  If false x0 = x2 and the process is repeated until x2 is close to zero. When the root is found the message printed is, 'Bisection root x value with precision {self.precision}: {x2:.{self.precision}f}'.  
The final method is secantMethod().  This function takes in no inputs from the user.  It first takes in the start and end points of the interval as x0 and x1. The function uses a while loop to check if func(x1) is close to zero within the given precision.  If not the change in x is found by computingx1 - x0.  The change in y is found by computing func(x1) - func(x2).  The change in y is divided by the change in x to find the slope.  Before the next step,  x0 is set to x1 and then the same equation from newtonsMethod() is used to find a new x1 value.
x1 = x1 -func(x1)/m  
The process is then repeated until x1 is close to zero within the given precision.
	For each of these root solver methods, the method will also plot out the calculated point for each iteration and its respective function value.  Each point has a label with a number to show the point in the iteration at which the point was found.  Also with this while the methods iterates through the code it will print a table of values with each found x value, y value, and % error.  It is noted that if the root that is found is near zero the % error will not approach 0 because the error is calculated using the new x value in the denominator.

	To run this system the user must first enter a function within the func() method.  Once entered the user can create a variable of type ‘root’ using a tuple interval and a given precision.  Next, the methods, funcPlotter(), newtonsMethod(), bisectionMethod(), and secantMethod() can be used to plot or find root values.  This system uses .numpy to calculate the function values and .matplotlib.pyplot to plot the given function.

This project taught me different things about my own coding ability and interests.  From this project, I learned more about how classes work and how they can be used to simplify interactions for the user.  Creating a class with all the functions makes finding roots and plotting much simpler for the user.  I also learned different numerical approximation methods which can be used to find the root of an unsolvable equation.  This may be applicable in future courses as I have a math minor and plan to take courses on the Fourier series and statistics.
	I also learned that I actually enjoy coding things that interest me.  Working through writing the code was enjoyable for me since I have an interest in math and problem-solving.  I plan to create other small projects in the future to keep my skills sharp and to want to learn more about skills I can learn that will be applicable in the electrical engineering field.  
If I had more time I may have implemented the use of the regular expression to take in user input for the given function.  Besides this, I would rather spend more time creating another project as this one seemed to have limits on things to enhance.  I am curious about is if there is a way to determine the number of roots within an interval prior to the method and then use the method to find all the roots in an interval.  Building on this I wonder if there is a way to find all the roots of an equation given the number of roots is not infinite i.e. not harmonic.
One thing I found challenging was ensuring that the newtonsMethod() function would determine a root in the given interval.  Sometimes if the interval start or end point was very close to a root it would find that root instead of the one within the interval.  Also with the newtonsMethod() method, it would find the derivative at some points to be extremely close to 0 which would mean,
x = x -func(x)/m
Would produce a new x value that is extremely less than the original x value, again putting the root out of the interval.  
	Advice I would give to future students is start this project early and ask questions.  I also this students should really try to pick a project that interests them the most.  If none do, they should create a project that will.  I think having some passion toward the project makes working on it alot more manageable and enjoyable.  Also picking a topic closely related to their major would allow student to talk about their project in interviews to further demonstrate their interest and skills in the field.

